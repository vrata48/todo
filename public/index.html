<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TODO</title>
    <link rel="stylesheet" href="styles.css">

    <!-- PWA Manifest -->
    <link rel="manifest" href="manifest.json">

    <!-- PWA Meta Tags -->
    <meta name="theme-color" content="#2563eb">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="TODO">

    <!-- Favicon and App Icons -->
    <link rel="icon" type="image/png" sizes="192x192" href="icon-192.png">
    <link rel="apple-touch-icon" href="icon-192.png">
</head>
<body>
    <!-- Login Screen -->
    <div id="loginScreen" class="login-screen">
        <div class="login-form">
            <h1>üîê TODO Login</h1>
            <div class="password-input-container">
                <input type="password" id="passwordInput" class="password-input" placeholder="Enter your password..." />
            </div>
            <button onclick="login()" class="login-btn">Login</button>
            <div id="loginError" class="error-message" style="display: none;"></div>
        </div>
    </div>

    <!-- Main App -->
    <div id="mainApp" class="main-app" style="display: none;">
        <div class="container">
            <!-- Header -->
            <header class="app-header">
                <h1>üìù TODO</h1>
                <button class="logout-btn" onclick="logout()">Logout</button>
            </header>

            <!-- Data Management Section - At the top for easy access -->
            <section class="data-management-section">
                <details class="data-management-details">
                    <summary class="data-management-summary">
                        üíæ Data Management
                    </summary>

                    <div class="data-management-content">
                        <!-- Export Section -->
                        <div class="export-section">
                            <h3>üì§ Export Data</h3>
                            <p class="export-description">Download your todos as a JSON file for backup or migration.</p>

                            <div class="export-options">
                                <label class="export-option">
                                    <input type="checkbox" id="includeCompletedExport" checked>
                                    <span>Include completed todos</span>
                                </label>
                            </div>

                            <div class="export-actions">
                                <button onclick="exportData()" class="export-btn">
                                    üì• Export All Data
                                </button>
                                <button onclick="showExportStats()" class="stats-btn">
                                    üìä View Stats
                                </button>
                            </div>
                        </div>

                        <!-- Import Section -->
                        <div class="import-section">
                            <h3>üì§ Import Data</h3>
                            <p class="import-description">Import todos from a JSON export file.</p>

                            <div class="import-file-area">
                                <input type="file" id="importFile" accept=".json" class="import-file-input">
                                <label for="importFile" class="import-file-label">
                                    üìÑ Choose JSON file...
                                </label>
                                <div class="import-file-info" id="importFileInfo" style="display: none;"></div>
                            </div>

                            <div class="import-options" id="importOptions" style="display: none;">
                                <h4>Import Options</h4>

                                <div class="import-option-group">
                                    <label class="import-strategy-label">Import Strategy:</label>
                                    <select id="importStrategy" class="import-strategy-select">
                                        <option value="replace">Replace existing data</option>
                                        <option value="merge">Merge with existing data</option>
                                        <option value="skip">Skip existing categories</option>
                                    </select>
                                </div>

                                <div class="import-option-group">
                                    <label class="import-option">
                                        <input type="checkbox" id="skipCompleted">
                                        <span>Skip completed todos</span>
                                    </label>
                                    <label class="import-option">
                                        <input type="checkbox" id="overwriteExisting">
                                        <span>Overwrite existing todos</span>
                                    </label>
                                </div>
                            </div>

                            <div class="import-actions" id="importActions" style="display: none;">
                                <button onclick="previewImport()" class="preview-btn">
                                    üëÅÔ∏è Preview Import
                                </button>
                                <button onclick="executeImport()" class="import-btn">
                                    üì§ Import Data
                                </button>
                            </div>
                        </div>
                    </div>
                </details>
            </section>

            <!-- Category Creation -->
            <section class="category-creation">
                <div class="input-group">
                    <input type="text" id="categoryInput" placeholder="New category name..." />
                    <button onclick="createCategory()" class="create-btn">Create Category</button>
                </div>
            </section>

            <!-- Category Tabs -->
            <section class="category-section">
                <div class="category-tabs" id="categoryTabs"></div>
            </section>

            <!-- Current Category Management -->
            <section class="category-management" id="categoryManagement" style="display: none;">
                <div class="category-title">
                    <h2 id="currentCategoryName" onclick="startRenameCategory()"></h2>
                </div>
                <div class="category-actions">
                    <button class="rename-btn" onclick="startRenameCategory()">Rename</button>
                    <button class="delete-btn" onclick="deleteCurrentCategory()">Delete</button>
                </div>
            </section>

            <!-- Todo Creation -->
            <section class="todo-creation" id="todoCreation" style="display: none;">
                <div class="input-group">
                    <input type="text" id="todoInput" placeholder="What needs to be done?" />
                    <label class="urgent-checkbox">
                        <input type="checkbox" id="urgentCheckbox" />
                        <span class="urgent-label">üî• Urgent</span>
                    </label>
                    <button onclick="addTodo()" class="add-btn">Add Todo</button>
                </div>
            </section>

            <!-- Todo List -->
            <main class="todo-main">
                <ul class="todo-list" id="todoList"></ul>
                <div id="dragIndicator" class="drag-indicator" style="display: none;"></div>
            </main>

            <!-- Footer Stats -->
            <footer class="app-footer">
                <div class="stats-and-actions">
                    <span class="stats-text" id="statsText"></span>
                    <button class="clear-btn" id="clearCompletedBtn" onclick="clearCompleted()" disabled style="display: none;">
                        Clear Completed
                    </button>
                </div>
            </footer>
        </div>
    </div>

    <!-- Export Stats Modal -->
    <div id="statsModal" class="modal" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <h3>üìä Export Statistics</h3>
                <button onclick="closeStatsModal()" class="modal-close">‚úï</button>
            </div>
            <div class="modal-body">
                <div id="statsContent">Loading...</div>
            </div>
        </div>
    </div>

    <!-- Import Preview Modal -->
    <div id="importPreviewModal" class="modal" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <h3>üëÅÔ∏è Import Preview</h3>
                <button onclick="closeImportPreviewModal()" class="modal-close">‚úï</button>
            </div>
            <div class="modal-body">
                <div id="importPreviewContent">Loading...</div>
            </div>
            <div class="modal-footer">
                <button onclick="closeImportPreviewModal()" class="cancel-btn">Cancel</button>
                <button onclick="executeImportFromPreview()" class="confirm-btn">Confirm Import</button>
            </div>
        </div>
    </div>

    <!-- Import Results Modal -->
    <div id="importResultsModal" class="modal" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <h3>‚úÖ Import Results</h3>
                <button onclick="closeImportResultsModal()" class="modal-close">‚úï</button>
            </div>
            <div class="modal-body">
                <div id="importResultsContent"></div>
            </div>
            <div class="modal-footer">
                <button onclick="closeImportResultsModal()" class="ok-btn">OK</button>
            </div>
        </div>
    </div>

    <script>
        // Global state
        let categories = [];
        let currentCategory = null;
        let todos = [];
        let nextId = 1;
        let editingId = null;
        let categoryCounts = {};
        let renamingCategory = false;
        let authToken = null;
        let draggedElement = null;
        let draggedIndex = -1;

        // Global variables for import/export
        let selectedImportFile = null;
        let importPreviewData = null;

        // Authentication functions
        function getAuthToken() {
            return localStorage.getItem('todoAuthToken');
        }

        function setAuthToken(token) {
            authToken = token;
            localStorage.setItem('todoAuthToken', token);
        }

        function clearAuthToken() {
            authToken = null;
            localStorage.removeItem('todoAuthToken');
        }

        async function login() {
            const passwordInput = document.getElementById('passwordInput');
            const errorDiv = document.getElementById('loginError');
            const password = passwordInput.value.trim();

            if (!password) {
                showError('Please enter a password');
                return;
            }

            try {
                const response = await fetch('/api/login', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ password })
                });

                const result = await response.json();

                if (result.success) {
                    setAuthToken(result.token);
                    showMainApp();
                    await loadCategories();
                } else {
                    showError(result.error || 'Login failed');
                }
            } catch (error) {
                showError('Connection error. Please try again.');
                console.error('Login error:', error);
            }
        }

        function logout() {
            clearAuthToken();
            showLoginScreen();
            resetAppState();
        }

        function resetAppState() {
            categories = [];
            currentCategory = null;
            todos = [];
            categoryCounts = {};
            document.getElementById('categoryTabs').innerHTML = '';
            document.getElementById('todoList').innerHTML = '';
            document.getElementById('categoryManagement').style.display = 'none';
            document.getElementById('todoCreation').style.display = 'none';
        }

        function showError(message) {
            const errorDiv = document.getElementById('loginError');
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
            setTimeout(() => {
                errorDiv.style.display = 'none';
            }, 5000);
        }

        function showLoginScreen() {
            document.getElementById('loginScreen').style.display = 'flex';
            document.getElementById('mainApp').style.display = 'none';
            document.getElementById('passwordInput').value = '';
        }

        function showMainApp() {
            document.getElementById('loginScreen').style.display = 'none';
            document.getElementById('mainApp').style.display = 'block';
        }

        // API functions
        async function authenticatedFetch(url, options = {}) {
            const token = getAuthToken();
            if (!token) {
                logout();
                throw new Error('No authentication token');
            }

            const headers = {
                'Authorization': `Bearer ${token}`,
                ...options.headers
            };

            const response = await fetch(url, { ...options, headers });

            if (response.status === 401) {
                logout();
                throw new Error('Authentication expired');
            }

            return response;
        }

        // Export functionality
        async function exportData() {
            try {
                const includeCompleted = document.getElementById('includeCompletedExport').checked;
                const response = await authenticatedFetch(`/api/export?includeCompleted=${includeCompleted}`);

                if (!response.ok) {
                    throw new Error('Export failed');
                }

                const blob = await response.blob();
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `todo-export-${new Date().toISOString().split('T')[0]}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                window.URL.revokeObjectURL(url);

                showNotification('Export completed successfully!', 'success');
            } catch (error) {
                console.error('Export error:', error);
                showNotification('Export failed. Please try again.', 'error');
            }
        }

        async function showExportStats() {
            try {
                const response = await authenticatedFetch('/api/export/stats');
                const stats = await response.json();

                const statsHtml = `
                    <div class="stats-grid">
                        <div class="stat-item">
                            <div class="stat-value">${stats.totalCategories}</div>
                            <div class="stat-label">Categories</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value">${stats.totalTodos}</div>
                            <div class="stat-label">Total Todos</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value">${stats.completedTodos}</div>
                            <div class="stat-label">Completed</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value">${stats.openTodos}</div>
                            <div class="stat-label">Open</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value">${stats.urgentTodos}</div>
                            <div class="stat-label">Urgent</div>
                        </div>
                    </div>
                    <div class="stats-details">
                        <p><strong>Oldest Todo:</strong> ${stats.oldestTodo ? new Date(stats.oldestTodo).toLocaleDateString() : 'N/A'}</p>
                        <p><strong>Newest Todo:</strong> ${stats.newestTodo ? new Date(stats.newestTodo).toLocaleDateString() : 'N/A'}</p>
                        <p><strong>Supported Formats:</strong> ${stats.exportFormats.join(', ')}</p>
                        <p><strong>Data Version:</strong> ${stats.supportedVersions[0]}</p>
                    </div>
                `;

                document.getElementById('statsContent').innerHTML = statsHtml;
                document.getElementById('statsModal').style.display = 'block';
            } catch (error) {
                console.error('Stats error:', error);
                showNotification('Failed to load statistics.', 'error');
            }
        }

        // Import functionality
        document.getElementById('importFile').addEventListener('change', function(event) {
            const file = event.target.files[0];
            if (file) {
                selectedImportFile = file;

                const fileInfo = document.getElementById('importFileInfo');
                fileInfo.innerHTML = `
                    <div class="file-info">
                        <strong>Selected file:</strong> ${file.name}<br>
                        <strong>Size:</strong> ${(file.size / 1024).toFixed(2)} KB<br>
                        <strong>Modified:</strong> ${new Date(file.lastModified).toLocaleDateString()}
                    </div>
                `;
                fileInfo.style.display = 'block';

                document.getElementById('importOptions').style.display = 'block';
                document.getElementById('importActions').style.display = 'block';
            }
        });

        async function previewImport() {
            if (!selectedImportFile) {
                showNotification('Please select a file first.', 'error');
                return;
            }

            try {
                const fileContent = await readFileAsText(selectedImportFile);
                const importData = JSON.parse(fileContent);

                importPreviewData = importData;

                // Validate data structure
                if (!importData.version || !importData.categories) {
                    throw new Error('Invalid file format');
                }

                const previewHtml = generateImportPreview(importData);
                document.getElementById('importPreviewContent').innerHTML = previewHtml;
                document.getElementById('importPreviewModal').style.display = 'block';

            } catch (error) {
                console.error('Preview error:', error);
                showNotification('Invalid file format or corrupted data.', 'error');
            }
        }

        function generateImportPreview(data) {
            const categories = Object.keys(data.categories);
            const totalTodos = Object.values(data.categories).reduce((sum, cat) => sum + cat.todos.length, 0);
            const totalCompleted = Object.values(data.categories).reduce((sum, cat) =>
                sum + cat.todos.filter(t => t.completed).length, 0);
            const totalUrgent = Object.values(data.categories).reduce((sum, cat) =>
                sum + cat.todos.filter(t => t.urgent).length, 0);

            let html = `
                <div class="import-preview">
                    <div class="preview-summary">
                        <h4>Import Summary</h4>
                        <div class="preview-stats">
                            <div class="preview-stat">
                                <span class="stat-value">${categories.length}</span>
                                <span class="stat-label">Categories</span>
                            </div>
                            <div class="preview-stat">
                                <span class="stat-value">${totalTodos}</span>
                                <span class="stat-label">Total Todos</span>
                            </div>
                            <div class="preview-stat">
                                <span class="stat-value">${totalCompleted}</span>
                                <span class="stat-label">Completed</span>
                            </div>
                            <div class="preview-stat">
                                <span class="stat-value">${totalUrgent}</span>
                                <span class="stat-label">Urgent</span>
                            </div>
                        </div>
                        <div class="preview-metadata">
                            <p><strong>Export Date:</strong> ${new Date(data.exportDate).toLocaleString()}</p>
                            <p><strong>Version:</strong> ${data.version}</p>
                        </div>
                    </div>

                    <div class="preview-categories">
                        <h4>Categories to Import</h4>
                        <div class="category-list">
            `;

            categories.forEach(categoryName => {
                const category = data.categories[categoryName];
                html += `
                    <div class="preview-category">
                        <div class="category-header">
                            <strong>${categoryName}</strong>
                            <span class="category-count">${category.todos.length} todos</span>
                        </div>
                        <div class="category-preview-todos">
                            ${category.todos.slice(0, 3).map(todo => `
                                <div class="preview-todo ${todo.completed ? 'completed' : ''} ${todo.urgent ? 'urgent' : ''}">
                                    ${todo.urgent ? 'üî• ' : ''}${todo.text}
                                    ${todo.completed ? ' ‚úì' : ''}
                                </div>
                            `).join('')}
                            ${category.todos.length > 3 ? `<div class="preview-more">... and ${category.todos.length - 3} more</div>` : ''}
                        </div>
                    </div>
                `;
            });

            html += `
                        </div>
                    </div>
                </div>
            `;

            return html;
        }

        async function executeImport() {
            if (!selectedImportFile) {
                showNotification('Please select a file first.', 'error');
                return;
            }

            try {
                const fileContent = await readFileAsText(selectedImportFile);
                const importData = JSON.parse(fileContent);

                const options = {
                    mergeStrategy: document.getElementById('importStrategy').value,
                    skipCompleted: document.getElementById('skipCompleted').checked,
                    overwriteExisting: document.getElementById('overwriteExisting').checked
                };

                const response = await authenticatedFetch('/api/import', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ data: importData, options })
                });

                const result = await response.json();

                if (result.success) {
                    showImportResults(result);
                    // Refresh the app data
                    await loadCategories();
                    if (currentCategory) {
                        await selectCategory(currentCategory);
                    }
                } else {
                    throw new Error(result.error || 'Import failed');
                }

            } catch (error) {
                console.error('Import error:', error);
                showNotification('Import failed: ' + error.message, 'error');
            }
        }

        async function executeImportFromPreview() {
            if (!importPreviewData) {
                showNotification('No data to import.', 'error');
                return;
            }

            closeImportPreviewModal();

            const options = {
                mergeStrategy: document.getElementById('importStrategy').value,
                skipCompleted: document.getElementById('skipCompleted').checked,
                overwriteExisting: document.getElementById('overwriteExisting').checked
            };

            try {
                const response = await authenticatedFetch('/api/import', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ data: importPreviewData, options })
                });

                const result = await response.json();

                if (result.success) {
                    showImportResults(result);
                    // Refresh the app data
                    await loadCategories();
                    if (currentCategory) {
                        await selectCategory(currentCategory);
                    }
                } else {
                    throw new Error(result.error || 'Import failed');
                }

            } catch (error) {
                console.error('Import error:', error);
                showNotification('Import failed: ' + error.message, 'error');
            }
        }

        function showImportResults(result) {
            const resultsHtml = `
                <div class="import-results">
                    <div class="results-summary">
                        <h4>${result.success ? '‚úÖ Import Successful!' : '‚ùå Import Failed'}</h4>
                        <p>${result.message}</p>
                    </div>

                    <div class="results-details">
                        <div class="result-stat">
                            <span class="result-label">Categories Processed:</span>
                            <span class="result-value">${result.results.categoriesProcessed}</span>
                        </div>
                        <div class="result-stat">
                            <span class="result-label">Categories Created:</span>
                            <span class="result-value">${result.results.categoriesCreated}</span>
                        </div>
                        <div class="result-stat">
                            <span class="result-label">Categories Skipped:</span>
                            <span class="result-value">${result.results.categoriesSkipped}</span>
                        </div>
                        <div class="result-stat">
                            <span class="result-label">Todos Imported:</span>
                            <span class="result-value">${result.results.todosImported}</span>
                        </div>
                        <div class="result-stat">
                            <span class="result-label">Todos Skipped:</span>
                            <span class="result-value">${result.results.todosSkipped}</span>
                        </div>
                    </div>

                    ${result.results.errors.length > 0 ? `
                        <div class="results-errors">
                            <h5>Errors:</h5>
                            ${result.results.errors.map(error => `
                                <div class="error-item">
                                    <strong>${error.category}:</strong> ${error.error}
                                </div>
                            `).join('')}
                        </div>
                    ` : ''}

                    <div class="results-metadata">
                        <p><strong>Imported from:</strong> Version ${result.importedFrom.version}</p>
                        <p><strong>Export Date:</strong> ${new Date(result.importedFrom.exportDate).toLocaleString()}</p>
                    </div>
                </div>
            `;

            document.getElementById('importResultsContent').innerHTML = resultsHtml;
            document.getElementById('importResultsModal').style.display = 'block';
        }

        // Utility functions
        function readFileAsText(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = e => resolve(e.target.result);
                reader.onerror = e => reject(e);
                reader.readAsText(file);
            });
        }

        function showNotification(message, type = 'info') {
            // Create a simple notification system
            const notification = document.createElement('div');
            notification.className = `notification notification-${type}`;
            notification.textContent = message;

            document.body.appendChild(notification);

            setTimeout(() => {
                notification.classList.add('show');
            }, 100);

            setTimeout(() => {
                notification.classList.remove('show');
                setTimeout(() => {
                    document.body.removeChild(notification);
                }, 300);
            }, 4000);
        }

        // Modal controls
        function closeStatsModal() {
            document.getElementById('statsModal').style.display = 'none';
        }

        function closeImportPreviewModal() {
            document.getElementById('importPreviewModal').style.display = 'none';
            importPreviewData = null;
        }

        function closeImportResultsModal() {
            document.getElementById('importResultsModal').style.display = 'none';
            // Reset import form
            document.getElementById('importFile').value = '';
            document.getElementById('importFileInfo').style.display = 'none';
            document.getElementById('importOptions').style.display = 'none';
            document.getElementById('importActions').style.display = 'none';
            selectedImportFile = null;
        }

        // Close modals when clicking outside
        window.addEventListener('click', function(event) {
            const modals = ['statsModal', 'importPreviewModal', 'importResultsModal'];
            modals.forEach(modalId => {
                const modal = document.getElementById(modalId);
                if (event.target === modal) {
                    modal.style.display = 'none';
                }
            });
        });

        // Category functions
        async function loadCategories() {
            try {
                const response = await authenticatedFetch('/api/categories');
                categories = await response.json();

                await loadAllCategoryCounts();
                renderCategories();

                if (categories.length > 0 && !currentCategory) {
                    await selectCategory(categories[0]);
                }
            } catch (error) {
                console.error('Failed to load categories:', error);
            }
        }

        async function loadAllCategoryCounts() {
            categoryCounts = {};
            for (const category of categories) {
                try {
                    const response = await authenticatedFetch(`/api/todos/${category}`);
                    const data = await response.json();
                    const todos = data.todos || [];
                    const completed = todos.filter(t => t.completed).length;
                    const open = todos.length - completed;
                    categoryCounts[category] = { open, completed, total: todos.length };
                } catch (error) {
                    categoryCounts[category] = { open: 0, completed: 0, total: 0 };
                }
            }
        }

        async function createCategory() {
            const input = document.getElementById('categoryInput');
            const name = input.value.trim();

            if (name === '' || categories.includes(name)) return;

            await saveTodos(name, [], 1);
            input.value = '';
            await loadCategories();
            await selectCategory(name);
        }

        async function selectCategory(category) {
            currentCategory = category;
            await loadTodos();
            renderCategories();
            updateCategoryUI();
        }

        function updateCategoryUI() {
            const managementSection = document.getElementById('categoryManagement');
            const todoSection = document.getElementById('todoCreation');
            const categoryNameEl = document.getElementById('currentCategoryName');

            if (currentCategory) {
                managementSection.style.display = 'block';
                todoSection.style.display = 'block';
                categoryNameEl.textContent = currentCategory;
            } else {
                managementSection.style.display = 'none';
                todoSection.style.display = 'none';
            }
        }

        async function deleteCurrentCategory() {
            if (!currentCategory) return;

            if (confirm(`Delete category "${currentCategory}" and all its todos?`)) {
                try {
                    await authenticatedFetch(`/api/categories/${currentCategory}`, { method: 'DELETE' });
                    await loadCategories();

                    if (categories.length > 0) {
                        await selectCategory(categories[0]);
                    } else {
                        currentCategory = null;
                        updateCategoryUI();
                        renderTodos();
                    }
                } catch (error) {
                    console.error('Failed to delete category:', error);
                }
            }
        }

        function renderCategories() {
            const tabs = document.getElementById('categoryTabs');
            tabs.innerHTML = categories.map(category => {
                const counts = categoryCounts[category] || { open: 0, completed: 0, total: 0 };
                const isActive = category === currentCategory;
                return `
                    <button class="category-tab ${isActive ? 'active' : ''}"
                            onclick="selectCategory('${category}')"
                            data-category="${category}">
                        <span class="category-name">${category}</span>
                        <span class="category-count">${counts.open}/${counts.total}</span>
                    </button>
                `;
            }).join('');
        }

        // Todo functions
        async function loadTodos() {
            if (!currentCategory) return;

            try {
                const response = await authenticatedFetch(`/api/todos/${currentCategory}`);
                const data = await response.json();
                todos = data.todos || [];
                nextId = data.nextId || 1;

                // Add urgent flag and position to existing todos that don't have them
                todos = todos.map(todo => ({
                    ...todo,
                    urgent: todo.urgent !== undefined ? todo.urgent : false,
                    position: todo.position !== undefined ? todo.position : todo.id
                }));

                // Sort by urgent first, then by position
                sortTodos();
                renderTodos();
            } catch (error) {
                console.error('Failed to load todos:', error);
                todos = [];
                nextId = 1;
                renderTodos();
            }
        }

        function sortTodos() {
            todos.sort((a, b) => {
                // First sort by urgent (urgent first)
                if (a.urgent && !b.urgent) return -1;
                if (!a.urgent && b.urgent) return 1;

                // Then sort by position
                return a.position - b.position;
            });
        }

        async function saveTodos(category = currentCategory, todosToSave = todos, nextIdToSave = nextId) {
            if (!category) return;

            try {
                await authenticatedFetch(`/api/todos/${category}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ todos: todosToSave, nextId: nextIdToSave })
                });

                if (category === currentCategory) {
                    await updateCategoryCount(category);
                }
            } catch (error) {
                console.error('Failed to save todos:', error);
            }
        }

        async function updateCategoryCount(category) {
            try {
                const response = await authenticatedFetch(`/api/todos/${category}`);
                const data = await response.json();
                const todos = data.todos || [];
                const completed = todos.filter(t => t.completed).length;
                const open = todos.length - completed;
                categoryCounts[category] = { open, completed, total: todos.length };
                renderCategories();
            } catch (error) {
                categoryCounts[category] = { open: 0, completed: 0, total: 0 };
            }
        }

        async function addTodo() {
            const input = document.getElementById('todoInput');
            const urgentCheckbox = document.getElementById('urgentCheckbox');
            const text = input.value.trim();
            const urgent = urgentCheckbox.checked;

            if (text === '' || !currentCategory) return;

            const newTodo = {
                id: nextId++,
                text: text,
                completed: false,
                urgent: urgent,
                position: todos.length + 1
            };

            todos.push(newTodo);
            sortTodos();

            input.value = '';
            urgentCheckbox.checked = false; // Reset to default
            await saveTodos();
            renderTodos();
        }

        async function toggleTodo(id) {
            const todo = todos.find(t => t.id === id);
            if (todo) {
                todo.completed = !todo.completed;
                await saveTodos();
                renderTodos();
            }
        }

        async function deleteTodo(id) {
            todos = todos.filter(t => t.id !== id);
            await saveTodos();
            renderTodos();
        }

        async function clearCompleted() {
            if (confirm('Delete all completed todos?')) {
                todos = todos.filter(t => !t.completed);
                await saveTodos();
                renderTodos();
            }
        }

        // Urgent flag functions
        async function toggleUrgent(id) {
            const todo = todos.find(t => t.id === id);
            if (todo) {
                todo.urgent = !todo.urgent;
                sortTodos();
                await saveTodos();
                renderTodos();
            }
        }

        // Drag and Drop functions
        function handleDragStart(e) {
            draggedElement = e.target.closest('.todo-item');
            draggedIndex = Array.from(draggedElement.parentNode.children).indexOf(draggedElement);

            draggedElement.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/html', draggedElement.outerHTML);
        }

        function handleDragEnd(e) {
            if (draggedElement) {
                draggedElement.classList.remove('dragging');
            }

            // Remove all drag indicators
            document.querySelectorAll('.todo-item').forEach(item => {
                item.classList.remove('drag-over-top', 'drag-over-bottom');
            });

            draggedElement = null;
            draggedIndex = -1;
        }

        function handleDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';

            const targetItem = e.target.closest('.todo-item');
            if (!targetItem || targetItem === draggedElement) return;

            // Remove all previous indicators
            document.querySelectorAll('.todo-item').forEach(item => {
                item.classList.remove('drag-over-top', 'drag-over-bottom');
            });

            // Calculate if we should insert above or below
            const rect = targetItem.getBoundingClientRect();
            const midpoint = rect.top + rect.height / 2;

            if (e.clientY < midpoint) {
                targetItem.classList.add('drag-over-top');
            } else {
                targetItem.classList.add('drag-over-bottom');
            }
        }

        function handleDrop(e) {
            e.preventDefault();

            const targetItem = e.target.closest('.todo-item');
            if (!targetItem || targetItem === draggedElement) return;

            const targetIndex = Array.from(targetItem.parentNode.children).indexOf(targetItem);
            const rect = targetItem.getBoundingClientRect();
            const midpoint = rect.top + rect.height / 2;
            const insertAfter = e.clientY >= midpoint;

            // Move the todo in the array
            const draggedTodo = todos[draggedIndex];
            todos.splice(draggedIndex, 1);

            let newIndex = targetIndex;
            if (draggedIndex < targetIndex) {
                newIndex = insertAfter ? targetIndex : targetIndex - 1;
            } else {
                newIndex = insertAfter ? targetIndex + 1 : targetIndex;
            }

            todos.splice(newIndex, 0, draggedTodo);

            // Update order values
            todos.forEach((todo, index) => {
                todo.position = index + 1;
            });

            // Save and re-render
            saveTodos();
            renderTodos();
        }

        // Edit functions
        function startEdit(id) {
            editingId = id;
            renderTodos();

            setTimeout(() => {
                const input = document.querySelector('.todo-text.editing');
                if (input) {
                    input.focus();
                    input.select();
                }
            }, 50);
        }

        async function saveEdit(id, newText) {
            const todo = todos.find(t => t.id === id);
            if (todo && newText.trim()) {
                todo.text = newText.trim();
                await saveTodos();
            }
            editingId = null;
            renderTodos();
        }

        function cancelEdit() {
            editingId = null;
            renderTodos();
        }

        // Rename category functions
        function startRenameCategory() {
            if (!currentCategory || renamingCategory) return;

            renamingCategory = true;
            const nameElement = document.getElementById('currentCategoryName');
            const currentName = nameElement.textContent;

            nameElement.innerHTML = `<input type="text" value="${currentName}"
                onblur="saveRenameCategory(this.value)"
                onkeydown="handleRenameKeydown(event, this.value)"
                class="category-rename-input">`;

            setTimeout(() => {
                const input = nameElement.querySelector('input');
                if (input) {
                    input.focus();
                    input.select();
                }
            }, 50);
        }

        function handleRenameKeydown(event, value) {
            if (event.key === 'Enter') {
                saveRenameCategory(value);
            } else if (event.key === 'Escape') {
                cancelRenameCategory();
            }
        }

        async function saveRenameCategory(newName) {
            if (!currentCategory || !renamingCategory) return;

            newName = newName.trim();
            if (newName === '' || newName === currentCategory) {
                cancelRenameCategory();
                return;
            }

            if (categories.includes(newName)) {
                alert('Category with this name already exists!');
                cancelRenameCategory();
                return;
            }

            try {
                const response = await authenticatedFetch(`/api/categories/${currentCategory}`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ newName })
                });

                if (response.ok) {
                    currentCategory = newName;
                    await loadCategories();
                    await selectCategory(newName);
                } else {
                    const error = await response.json();
                    alert(error.error || 'Failed to rename category');
                    cancelRenameCategory();
                }
            } catch (error) {
                console.error('Failed to rename category:', error);
                alert('Failed to rename category');
                cancelRenameCategory();
            }

            renamingCategory = false;
        }

        function cancelRenameCategory() {
            renamingCategory = false;
            document.getElementById('currentCategoryName').textContent = currentCategory;
        }

        // Link conversion functions
        function createLinkCaption(url) {
            try {
                const urlObj = new URL(url);
                const domain = urlObj.hostname.replace('www.', '');
                const path = urlObj.pathname;

                if (domain.includes('atlassian.net')) {
                    const pathParts = path.split('/');
                    if (pathParts.includes('browse')) {
                        const ticketId = pathParts[pathParts.indexOf('browse') + 1];
                        return `Jira: ${ticketId}`;
                    } else if (pathParts.includes('wiki')) {
                        let title = pathParts[pathParts.length - 1];
                        if (title && title !== 'wiki' && title !== 'spaces') {
                            title = decodeURIComponent(title).replace(/\+/g, ' ');
                            if (title.length > 40) {
                                title = title.substring(0, 37) + '...';
                            }
                            return `Wiki: ${title}`;
                        }
                        return `Confluence Wiki`;
                    }
                    return `Atlassian: ${domain}`;
                }

                if (domain.includes('github.com')) {
                    const pathParts = path.split('/').filter(p => p);
                    if (pathParts.length >= 2) {
                        return `GitHub: ${pathParts[0]}/${pathParts[1]}`;
                    }
                    return 'GitHub';
                }

                const domainParts = domain.split('.');
                let siteName = domainParts[0];
                siteName = siteName.charAt(0).toUpperCase() + siteName.slice(1);

                if (path && path !== '/' && path.length > 1) {
                    const pathName = path.split('/').filter(p => p)[0];
                    if (pathName && pathName.length < 20) {
                        return `${siteName}: ${pathName}`;
                    }
                }

                return siteName;
            } catch (error) {
                return url.length > 30 ? url.substring(0, 27) + '...' : url;
            }
        }

        function convertAllLinks(text) {
            let result = text;

            // Convert HTTP/HTTPS URLs to clickable links with captions
            result = result.replace(/(https?:\/\/[^\s]+)/g, (match, url) => {
                const caption = createLinkCaption(url);
                return `<a href="${url}" target="_blank" class="http-link" title="${url}">${caption}</a>`;
            });

            // Convert DEPM and DDS patterns
            const parts = result.split(/(<a[^>]*>.*?<\/a>)/);
            result = parts.map(part => {
                if (part.startsWith('<a ')) {
                    return part;
                }
                return part.replace(/(?:DEPM|DDS)-(\d+)/g, (match, number) => {
                    const ticketType = match.split('-')[0];
                    return `<a href="https://infor.atlassian.net/browse/${ticketType}-${number}" target="_blank" class="depm-link">${ticketType}-${number}</a>`;
                });
            }).join('');

            return result;
        }

        function renderTodos() {
            const todoList = document.getElementById('todoList');
            const statsText = document.getElementById('statsText');
            const clearBtn = document.getElementById('clearCompletedBtn');

            if (!currentCategory) {
                todoList.innerHTML = '<li class="empty-state">Select or create a category to start adding todos</li>';
                statsText.textContent = '';
                clearBtn.style.display = 'none';
                return;
            }

            if (todos.length === 0) {
                todoList.innerHTML = '<li class="empty-state">No todos in this category yet. Add one above!</li>';
                statsText.textContent = '';
                clearBtn.style.display = 'none';
                return;
            }

            const completedCount = todos.filter(t => t.completed).length;
            const showClearBtn = completedCount > 0;
            clearBtn.style.display = showClearBtn ? 'inline-block' : 'none';
            clearBtn.disabled = !showClearBtn;

            todoList.innerHTML = todos.map((todo, index) => {
                const isEditing = editingId === todo.id;

                return `
                    <li class="todo-item ${todo.completed ? 'completed' : ''} ${todo.urgent ? 'urgent' : ''}"
                        draggable="true"
                        data-todo-id="${todo.id}"
                        data-index="${index}"
                        ondragstart="handleDragStart(event)"
                        ondragend="handleDragEnd(event)"
                        ondragover="handleDragOver(event)"
                        ondrop="handleDrop(event)">

                        <div class="todo-drag-handle">‚ãÆ‚ãÆ</div>

                        <div class="todo-urgent">
                            <button class="urgent-toggle ${todo.urgent ? 'active' : ''}"
                                    onclick="toggleUrgent(${todo.id})"
                                    title="${todo.urgent ? 'Remove urgent flag' : 'Mark as urgent'}"
                                    ${todo.completed ? 'disabled' : ''}>
                                ${todo.urgent ? 'üî•' : '‚ö™'}
                            </button>
                        </div>

                        <div class="todo-content">
                            <input type="checkbox" class="todo-checkbox"
                                   ${todo.completed ? 'checked' : ''}
                                   onchange="toggleTodo(${todo.id})">
                            ${isEditing ?
                                `<input type="text" class="todo-text editing"
                                        value="${todo.text}"
                                        onblur="saveEdit(${todo.id}, this.value)"
                                        onkeydown="if(event.key==='Enter') saveEdit(${todo.id}, this.value); if(event.key==='Escape') cancelEdit()">` :
                                `<span class="todo-text" onclick="startEdit(${todo.id})">${convertAllLinks(todo.text)}</span>`
                            }
                        </div>
                        <div class="todo-actions">
                            <button class="edit-btn" onclick="startEdit(${todo.id})" title="Edit">‚úèÔ∏è</button>
                            <button class="delete-btn" onclick="deleteTodo(${todo.id})" title="Delete">üóëÔ∏è</button>
                        </div>
                    </li>
                `;
            }).join('');

            const completed = todos.filter(t => t.completed).length;
            const total = todos.length;
            statsText.textContent = `${completed} of ${total} completed`;
        }

        // Initialize app
        function initApp() {
            const token = getAuthToken();
            if (token) {
                authToken = token;
                showMainApp();
                loadCategories();
            } else {
                showLoginScreen();
            }
        }

        // Event listeners
        document.addEventListener('DOMContentLoaded', () => {
            // Password input enter key
            document.getElementById('passwordInput').addEventListener('keypress', function(e) {
                if (e.key === 'Enter') login();
            });

            // Category input enter key
            document.getElementById('categoryInput').addEventListener('keypress', function(e) {
                if (e.key === 'Enter') createCategory();
            });

            // Todo input enter key
            document.getElementById('todoInput').addEventListener('keypress', function(e) {
                if (e.key === 'Enter') addTodo();
            });

            // Initialize app
            initApp();
        });

        // Register minimal Service Worker for PWA (installable but no caching)
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/sw.js')
                    .then((registration) => {
                        console.log('Minimal SW registered for PWA install capability');

                        // Always update to get latest SW
                        registration.update();

                        // Handle SW updates
                        registration.addEventListener('updatefound', () => {
                            const newWorker = registration.installing;
                            newWorker.addEventListener('statechange', () => {
                                if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                                    // New SW is available, activate it immediately
                                    newWorker.postMessage({type: 'SKIP_WAITING'});
                                }
                            });
                        });
                    })
                    .catch((registrationError) => {
                        console.log('SW registration failed: ', registrationError);
                    });
            });
        }

        // PWA Install Prompt
        let deferredPrompt;
        window.addEventListener('beforeinstallprompt', (e) => {
            e.preventDefault();
            deferredPrompt = e;
            console.log('PWA install available');
        });
    </script>
</body>
</html>