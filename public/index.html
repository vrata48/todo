<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TODO</title>
    <link rel="stylesheet" href="styles.css">

    <!-- PWA Manifest -->
    <link rel="manifest" href="manifest.json">

    <!-- PWA Meta Tags -->
    <meta name="theme-color" content="#2563eb">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="TODO">

    <!-- Favicon and App Icons -->
    <link rel="icon" type="image/png" sizes="192x192" href="icon-192.png">
    <link rel="apple-touch-icon" href="icon-192.png">
</head>
<body>
    <!-- Login Screen -->
    <div id="loginScreen" class="login-screen">
        <div class="login-form">
            <h1>üîê TODO Login</h1>
            <div class="password-input-container">
                <input type="password" id="passwordInput" class="password-input" placeholder="Enter your password..." />
            </div>
            <button onclick="login()" class="login-btn">Login</button>
            <div id="loginError" class="error-message" style="display: none;"></div>
        </div>
    </div>

    <!-- Main App -->
    <div id="mainApp" class="main-app" style="display: none;">
        <div class="container">
            <!-- Header -->
            <header class="app-header">
                <h1>üìù TODO</h1>
                <button class="logout-btn" onclick="logout()">Logout</button>
            </header>

            <!-- Category Creation -->
            <section class="category-creation">
                <div class="input-group">
                    <input type="text" id="categoryInput" placeholder="New category name..." />
                    <button onclick="createCategory()" class="create-btn">Create Category</button>
                </div>
            </section>

            <!-- Category Tabs -->
            <section class="category-section">
                <div class="category-tabs" id="categoryTabs"></div>
            </section>

            <!-- Current Category Management -->
            <section class="category-management" id="categoryManagement" style="display: none;">
                <div class="category-title">
                    <h2 id="currentCategoryName" onclick="startRenameCategory()"></h2>
                </div>
                <div class="category-actions">
                    <button class="rename-btn" onclick="startRenameCategory()">Rename</button>
                    <button class="delete-btn" onclick="deleteCurrentCategory()">Delete</button>
                </div>
            </section>

            <!-- Todo Creation -->
            <section class="todo-creation" id="todoCreation" style="display: none;">
                <div class="input-group">
                    <input type="text" id="todoInput" placeholder="What needs to be done?" />
                    <label class="urgent-checkbox">
                        <input type="checkbox" id="urgentCheckbox" />
                        <span class="urgent-label">üî• Urgent</span>
                    </label>
                    <button onclick="addTodo()" class="add-btn">Add Todo</button>
                </div>
            </section>

            <!-- Todo List -->
            <main class="todo-main">
                <ul class="todo-list" id="todoList"></ul>
                <div id="dragIndicator" class="drag-indicator" style="display: none;"></div>
            </main>

            <!-- Footer Stats -->
            <footer class="app-footer">
                <div class="stats-and-actions">
                    <span class="stats-text" id="statsText"></span>
                    <button class="clear-btn" id="clearCompletedBtn" onclick="clearCompleted()" disabled style="display: none;">
                        Clear Completed
                    </button>
                </div>
            </footer>
        </div>
    </div>

    <script>
        // Global state
        let categories = [];
        let currentCategory = null;
        let todos = [];
        let nextId = 1;
        let editingId = null;
        let categoryCounts = {};
        let renamingCategory = false;
        let authToken = null;
        let draggedElement = null;
        let draggedIndex = -1;

        // Authentication functions
        function getAuthToken() {
            return localStorage.getItem('todoAuthToken');
        }

        function setAuthToken(token) {
            authToken = token;
            localStorage.setItem('todoAuthToken', token);
        }

        function clearAuthToken() {
            authToken = null;
            localStorage.removeItem('todoAuthToken');
        }

        async function login() {
            const passwordInput = document.getElementById('passwordInput');
            const errorDiv = document.getElementById('loginError');
            const password = passwordInput.value.trim();

            if (!password) {
                showError('Please enter a password');
                return;
            }

            try {
                const response = await fetch('/api/login', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ password })
                });

                const result = await response.json();

                if (result.success) {
                    setAuthToken(result.token);
                    showMainApp();
                    await loadCategories();
                } else {
                    showError(result.error || 'Login failed');
                }
            } catch (error) {
                showError('Connection error. Please try again.');
                console.error('Login error:', error);
            }
        }

        function logout() {
            clearAuthToken();
            showLoginScreen();
            resetAppState();
        }

        function resetAppState() {
            categories = [];
            currentCategory = null;
            todos = [];
            categoryCounts = {};
            document.getElementById('categoryTabs').innerHTML = '';
            document.getElementById('todoList').innerHTML = '';
            document.getElementById('categoryManagement').style.display = 'none';
            document.getElementById('todoCreation').style.display = 'none';
        }

        function showError(message) {
            const errorDiv = document.getElementById('loginError');
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
            setTimeout(() => {
                errorDiv.style.display = 'none';
            }, 5000);
        }

        function showLoginScreen() {
            document.getElementById('loginScreen').style.display = 'flex';
            document.getElementById('mainApp').style.display = 'none';
            document.getElementById('passwordInput').value = '';
        }

        function showMainApp() {
            document.getElementById('loginScreen').style.display = 'none';
            document.getElementById('mainApp').style.display = 'block';
        }

        // API functions
        async function authenticatedFetch(url, options = {}) {
            const token = getAuthToken();
            if (!token) {
                logout();
                throw new Error('No authentication token');
            }

            const headers = {
                'Authorization': `Bearer ${token}`,
                ...options.headers
            };

            const response = await fetch(url, { ...options, headers });

            if (response.status === 401) {
                logout();
                throw new Error('Authentication expired');
            }

            return response;
        }

        // Category functions
        async function loadCategories() {
            try {
                const response = await authenticatedFetch('/api/categories');
                categories = await response.json();

                await loadAllCategoryCounts();
                renderCategories();

                if (categories.length > 0 && !currentCategory) {
                    await selectCategory(categories[0]);
                }
            } catch (error) {
                console.error('Failed to load categories:', error);
            }
        }

        async function loadAllCategoryCounts() {
            categoryCounts = {};
            for (const category of categories) {
                try {
                    const response = await authenticatedFetch(`/api/todos/${category}`);
                    const data = await response.json();
                    const todos = data.todos || [];
                    const completed = todos.filter(t => t.completed).length;
                    const open = todos.length - completed;
                    categoryCounts[category] = { open, completed, total: todos.length };
                } catch (error) {
                    categoryCounts[category] = { open: 0, completed: 0, total: 0 };
                }
            }
        }

        async function createCategory() {
            const input = document.getElementById('categoryInput');
            const name = input.value.trim();

            if (name === '' || categories.includes(name)) return;

            await saveTodos(name, [], 1);
            input.value = '';
            await loadCategories();
            await selectCategory(name);
        }

        async function selectCategory(category) {
            currentCategory = category;
            await loadTodos();
            renderCategories();
            updateCategoryUI();
        }

        function updateCategoryUI() {
            const managementSection = document.getElementById('categoryManagement');
            const todoSection = document.getElementById('todoCreation');
            const categoryNameEl = document.getElementById('currentCategoryName');

            if (currentCategory) {
                managementSection.style.display = 'block';
                todoSection.style.display = 'block';
                categoryNameEl.textContent = currentCategory;
            } else {
                managementSection.style.display = 'none';
                todoSection.style.display = 'none';
            }
        }

        async function deleteCurrentCategory() {
            if (!currentCategory) return;

            if (confirm(`Delete category "${currentCategory}" and all its todos?`)) {
                try {
                    await authenticatedFetch(`/api/categories/${currentCategory}`, { method: 'DELETE' });
                    await loadCategories();

                    if (categories.length > 0) {
                        await selectCategory(categories[0]);
                    } else {
                        currentCategory = null;
                        updateCategoryUI();
                        renderTodos();
                    }
                } catch (error) {
                    console.error('Failed to delete category:', error);
                }
            }
        }

        function renderCategories() {
            const tabs = document.getElementById('categoryTabs');
            tabs.innerHTML = categories.map(category => {
                const counts = categoryCounts[category] || { open: 0, completed: 0, total: 0 };
                const isActive = category === currentCategory;
                return `
                    <button class="category-tab ${isActive ? 'active' : ''}"
                            onclick="selectCategory('${category}')"
                            data-category="${category}">
                        <span class="category-name">${category}</span>
                        <span class="category-count">${counts.open}/${counts.total}</span>
                    </button>
                `;
            }).join('');
        }

        // Todo functions
        async function loadTodos() {
            if (!currentCategory) return;

            try {
                const response = await authenticatedFetch(`/api/todos/${currentCategory}`);
                const data = await response.json();
                todos = data.todos || [];
                nextId = data.nextId || 1;

                // Add urgent flag and position to existing todos that don't have them
                todos = todos.map(todo => ({
                    ...todo,
                    urgent: todo.urgent !== undefined ? todo.urgent : false,
                    position: todo.position !== undefined ? todo.position : todo.id
                }));

                // Sort by urgent first, then by position
                sortTodos();
                renderTodos();
            } catch (error) {
                console.error('Failed to load todos:', error);
                todos = [];
                nextId = 1;
                renderTodos();
            }
        }

        function sortTodos() {
            todos.sort((a, b) => {
                // First sort by urgent (urgent first)
                if (a.urgent && !b.urgent) return -1;
                if (!a.urgent && b.urgent) return 1;

                // Then sort by position
                return a.position - b.position;
            });
        }

        async function saveTodos(category = currentCategory, todosToSave = todos, nextIdToSave = nextId) {
            if (!category) return;

            try {
                await authenticatedFetch(`/api/todos/${category}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ todos: todosToSave, nextId: nextIdToSave })
                });

                if (category === currentCategory) {
                    await updateCategoryCount(category);
                }
            } catch (error) {
                console.error('Failed to save todos:', error);
            }
        }

        async function updateCategoryCount(category) {
            try {
                const response = await authenticatedFetch(`/api/todos/${category}`);
                const data = await response.json();
                const todos = data.todos || [];
                const completed = todos.filter(t => t.completed).length;
                const open = todos.length - completed;
                categoryCounts[category] = { open, completed, total: todos.length };
                renderCategories();
            } catch (error) {
                categoryCounts[category] = { open: 0, completed: 0, total: 0 };
            }
        }

        async function addTodo() {
            const input = document.getElementById('todoInput');
            const urgentCheckbox = document.getElementById('urgentCheckbox');
            const text = input.value.trim();
            const urgent = urgentCheckbox.checked;

            if (text === '' || !currentCategory) return;

            const newTodo = {
                id: nextId++,
                text: text,
                completed: false,
                urgent: urgent,
                position: todos.length + 1
            };

            todos.push(newTodo);
            sortTodos();

            input.value = '';
            urgentCheckbox.checked = false; // Reset to default
            await saveTodos();
            renderTodos();
        }

        async function toggleTodo(id) {
            const todo = todos.find(t => t.id === id);
            if (todo) {
                todo.completed = !todo.completed;
                await saveTodos();
                renderTodos();
            }
        }

        async function deleteTodo(id) {
            todos = todos.filter(t => t.id !== id);
            await saveTodos();
            renderTodos();
        }

        async function clearCompleted() {
            if (confirm('Delete all completed todos?')) {
                todos = todos.filter(t => !t.completed);
                await saveTodos();
                renderTodos();
            }
        }

        // Urgent flag functions
        async function toggleUrgent(id) {
            const todo = todos.find(t => t.id === id);
            if (todo) {
                todo.urgent = !todo.urgent;
                sortTodos();
                await saveTodos();
                renderTodos();
            }
        }

        // Drag and Drop functions
        function handleDragStart(e) {
            draggedElement = e.target.closest('.todo-item');
            draggedIndex = Array.from(draggedElement.parentNode.children).indexOf(draggedElement);

            draggedElement.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/html', draggedElement.outerHTML);
        }

        function handleDragEnd(e) {
            if (draggedElement) {
                draggedElement.classList.remove('dragging');
            }

            // Remove all drag indicators
            document.querySelectorAll('.todo-item').forEach(item => {
                item.classList.remove('drag-over-top', 'drag-over-bottom');
            });

            draggedElement = null;
            draggedIndex = -1;
        }

        function handleDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';

            const targetItem = e.target.closest('.todo-item');
            if (!targetItem || targetItem === draggedElement) return;

            // Remove all previous indicators
            document.querySelectorAll('.todo-item').forEach(item => {
                item.classList.remove('drag-over-top', 'drag-over-bottom');
            });

            // Calculate if we should insert above or below
            const rect = targetItem.getBoundingClientRect();
            const midpoint = rect.top + rect.height / 2;

            if (e.clientY < midpoint) {
                targetItem.classList.add('drag-over-top');
            } else {
                targetItem.classList.add('drag-over-bottom');
            }
        }

        function handleDrop(e) {
            e.preventDefault();

            const targetItem = e.target.closest('.todo-item');
            if (!targetItem || targetItem === draggedElement) return;

            const targetIndex = Array.from(targetItem.parentNode.children).indexOf(targetItem);
            const rect = targetItem.getBoundingClientRect();
            const midpoint = rect.top + rect.height / 2;
            const insertAfter = e.clientY >= midpoint;

            // Move the todo in the array
            const draggedTodo = todos[draggedIndex];
            todos.splice(draggedIndex, 1);

            let newIndex = targetIndex;
            if (draggedIndex < targetIndex) {
                newIndex = insertAfter ? targetIndex : targetIndex - 1;
            } else {
                newIndex = insertAfter ? targetIndex + 1 : targetIndex;
            }

            todos.splice(newIndex, 0, draggedTodo);

            // Update order values
            todos.forEach((todo, index) => {
                todo.position = index + 1;
            });

            // Save and re-render
            saveTodos();
            renderTodos();
        }

        // Edit functions
        function startEdit(id) {
            editingId = id;
            renderTodos();

            setTimeout(() => {
                const input = document.querySelector('.todo-text.editing');
                if (input) {
                    input.focus();
                    input.select();
                }
            }, 50);
        }

        async function saveEdit(id, newText) {
            const todo = todos.find(t => t.id === id);
            if (todo && newText.trim()) {
                todo.text = newText.trim();
                await saveTodos();
            }
            editingId = null;
            renderTodos();
        }

        function cancelEdit() {
            editingId = null;
            renderTodos();
        }

        // Rename category functions
        function startRenameCategory() {
            if (!currentCategory || renamingCategory) return;

            renamingCategory = true;
            const nameElement = document.getElementById('currentCategoryName');
            const currentName = nameElement.textContent;

            nameElement.innerHTML = `<input type="text" value="${currentName}"
                onblur="saveRenameCategory(this.value)"
                onkeydown="handleRenameKeydown(event, this.value)"
                class="category-rename-input">`;

            setTimeout(() => {
                const input = nameElement.querySelector('input');
                if (input) {
                    input.focus();
                    input.select();
                }
            }, 50);
        }

        function handleRenameKeydown(event, value) {
            if (event.key === 'Enter') {
                saveRenameCategory(value);
            } else if (event.key === 'Escape') {
                cancelRenameCategory();
            }
        }

        async function saveRenameCategory(newName) {
            if (!currentCategory || !renamingCategory) return;

            newName = newName.trim();
            if (newName === '' || newName === currentCategory) {
                cancelRenameCategory();
                return;
            }

            if (categories.includes(newName)) {
                alert('Category with this name already exists!');
                cancelRenameCategory();
                return;
            }

            try {
                const response = await authenticatedFetch(`/api/categories/${currentCategory}`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ newName })
                });

                if (response.ok) {
                    currentCategory = newName;
                    await loadCategories();
                    await selectCategory(newName);
                } else {
                    const error = await response.json();
                    alert(error.error || 'Failed to rename category');
                    cancelRenameCategory();
                }
            } catch (error) {
                console.error('Failed to rename category:', error);
                alert('Failed to rename category');
                cancelRenameCategory();
            }

            renamingCategory = false;
        }

        function cancelRenameCategory() {
            renamingCategory = false;
            document.getElementById('currentCategoryName').textContent = currentCategory;
        }

        // Link conversion functions
        function createLinkCaption(url) {
            try {
                const urlObj = new URL(url);
                const domain = urlObj.hostname.replace('www.', '');
                const path = urlObj.pathname;

                if (domain.includes('atlassian.net')) {
                    const pathParts = path.split('/');
                    if (pathParts.includes('browse')) {
                        const ticketId = pathParts[pathParts.indexOf('browse') + 1];
                        return `Jira: ${ticketId}`;
                    } else if (pathParts.includes('wiki')) {
                        let title = pathParts[pathParts.length - 1];
                        if (title && title !== 'wiki' && title !== 'spaces') {
                            title = decodeURIComponent(title).replace(/\+/g, ' ');
                            if (title.length > 40) {
                                title = title.substring(0, 37) + '...';
                            }
                            return `Wiki: ${title}`;
                        }
                        return `Confluence Wiki`;
                    }
                    return `Atlassian: ${domain}`;
                }

                if (domain.includes('github.com')) {
                    const pathParts = path.split('/').filter(p => p);
                    if (pathParts.length >= 2) {
                        return `GitHub: ${pathParts[0]}/${pathParts[1]}`;
                    }
                    return 'GitHub';
                }

                const domainParts = domain.split('.');
                let siteName = domainParts[0];
                siteName = siteName.charAt(0).toUpperCase() + siteName.slice(1);

                if (path && path !== '/' && path.length > 1) {
                    const pathName = path.split('/').filter(p => p)[0];
                    if (pathName && pathName.length < 20) {
                        return `${siteName}: ${pathName}`;
                    }
                }

                return siteName;
            } catch (error) {
                return url.length > 30 ? url.substring(0, 27) + '...' : url;
            }
        }

        function convertAllLinks(text) {
            let result = text;

            // Convert HTTP/HTTPS URLs to clickable links with captions
            result = result.replace(/(https?:\/\/[^\s]+)/g, (match, url) => {
                const caption = createLinkCaption(url);
                return `<a href="${url}" target="_blank" class="http-link" title="${url}">${caption}</a>`;
            });

            // Convert DEPM and DDS patterns
            const parts = result.split(/(<a[^>]*>.*?<\/a>)/);
            result = parts.map(part => {
                if (part.startsWith('<a ')) {
                    return part;
                }
                return part.replace(/(?:DEPM|DDS)-(\d+)/g, (match, number) => {
                    const ticketType = match.split('-')[0];
                    return `<a href="https://infor.atlassian.net/browse/${ticketType}-${number}" target="_blank" class="depm-link">${ticketType}-${number}</a>`;
                });
            }).join('');

            return result;
        }

        function renderTodos() {
            const todoList = document.getElementById('todoList');
            const statsText = document.getElementById('statsText');
            const clearBtn = document.getElementById('clearCompletedBtn');

            if (!currentCategory) {
                todoList.innerHTML = '<li class="empty-state">Select or create a category to start adding todos</li>';
                statsText.textContent = '';
                clearBtn.style.display = 'none';
                return;
            }

            if (todos.length === 0) {
                todoList.innerHTML = '<li class="empty-state">No todos in this category yet. Add one above!</li>';
                statsText.textContent = '';
                clearBtn.style.display = 'none';
                return;
            }

            const completedCount = todos.filter(t => t.completed).length;
            const showClearBtn = completedCount > 0;
            clearBtn.style.display = showClearBtn ? 'inline-block' : 'none';
            clearBtn.disabled = !showClearBtn;

            todoList.innerHTML = todos.map((todo, index) => {
                const isEditing = editingId === todo.id;

                return `
                    <li class="todo-item ${todo.completed ? 'completed' : ''} ${todo.urgent ? 'urgent' : ''}"
                        draggable="true"
                        data-todo-id="${todo.id}"
                        data-index="${index}"
                        ondragstart="handleDragStart(event)"
                        ondragend="handleDragEnd(event)"
                        ondragover="handleDragOver(event)"
                        ondrop="handleDrop(event)">

                        <div class="todo-drag-handle">‚ãÆ‚ãÆ</div>

                        <div class="todo-urgent">
                            <button class="urgent-toggle ${todo.urgent ? 'active' : ''}"
                                    onclick="toggleUrgent(${todo.id})"
                                    title="${todo.urgent ? 'Remove urgent flag' : 'Mark as urgent'}"
                                    ${todo.completed ? 'disabled' : ''}>
                                ${todo.urgent ? 'üî•' : '‚ö™'}
                            </button>
                        </div>

                        <div class="todo-content">
                            <input type="checkbox" class="todo-checkbox"
                                   ${todo.completed ? 'checked' : ''}
                                   onchange="toggleTodo(${todo.id})">
                            ${isEditing ?
                                `<input type="text" class="todo-text editing"
                                        value="${todo.text}"
                                        onblur="saveEdit(${todo.id}, this.value)"
                                        onkeydown="if(event.key==='Enter') saveEdit(${todo.id}, this.value); if(event.key==='Escape') cancelEdit()">` :
                                `<span class="todo-text" onclick="startEdit(${todo.id})">${convertAllLinks(todo.text)}</span>`
                            }
                        </div>
                        <div class="todo-actions">
                            <button class="edit-btn" onclick="startEdit(${todo.id})" title="Edit">‚úèÔ∏è</button>
                            <button class="delete-btn" onclick="deleteTodo(${todo.id})" title="Delete">üóëÔ∏è</button>
                        </div>
                    </li>
                `;
            }).join('');

            const completed = todos.filter(t => t.completed).length;
            const total = todos.length;
            statsText.textContent = `${completed} of ${total} completed`;
        }

        // Initialize app
        function initApp() {
            const token = getAuthToken();
            if (token) {
                authToken = token;
                showMainApp();
                loadCategories();
            } else {
                showLoginScreen();
            }
        }

        // Event listeners
        document.addEventListener('DOMContentLoaded', () => {
            // Password input enter key
            document.getElementById('passwordInput').addEventListener('keypress', function(e) {
                if (e.key === 'Enter') login();
            });

            // Category input enter key
            document.getElementById('categoryInput').addEventListener('keypress', function(e) {
                if (e.key === 'Enter') createCategory();
            });

            // Todo input enter key
            document.getElementById('todoInput').addEventListener('keypress', function(e) {
                if (e.key === 'Enter') addTodo();
            });

            // Initialize app
            initApp();
        });

        // Register minimal Service Worker for PWA (installable but no caching)
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/sw.js')
                    .then((registration) => {
                        console.log('Minimal SW registered for PWA install capability');

                        // Always update to get latest SW
                        registration.update();

                        // Handle SW updates
                        registration.addEventListener('updatefound', () => {
                            const newWorker = registration.installing;
                            newWorker.addEventListener('statechange', () => {
                                if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                                    // New SW is available, activate it immediately
                                    newWorker.postMessage({type: 'SKIP_WAITING'});
                                }
                            });
                        });
                    })
                    .catch((registrationError) => {
                        console.log('SW registration failed: ', registrationError);
                    });
            });
        }

        // PWA Install Prompt
        let deferredPrompt;
        window.addEventListener('beforeinstallprompt', (e) => {
            e.preventDefault();
            deferredPrompt = e;
            console.log('PWA install available');
        });
    </script>
</body>
</html>